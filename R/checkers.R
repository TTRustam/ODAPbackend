# TODO: AgeInt should be optional. If not given, it can be calculated from Age.
# Therefore minimal columns are Age, Deaths, Exposures; example data should look
# this way

# TODO: in Age heaping diagnostics specify which ages are checked.
# give high medium low.

# TODO: check plotly scale translation (scale_y_log10)

# TODO: plot lines in middle of age group, i.e. 42.5, but show age interval (40-44)
# on hover tip. create age_label variable. This is only for abridged data.

# TODO: bar plots should properly cover age intervals

# TODO: give JC a text blob for "Ages to include in model fit",
# also annotate extrapolation jump off line

# TODO: in results plots make use of columns like Sex to include in plot titles

# TODO: PG wants nqx plot for probabilities
# TODO: label the quantile lines as such

# TODO: extrapfit ages should follow from OAG
# TODO: add reset button
# TODO: in data_out from lifetable, include grouping information.
#       For now look for "Sex","Time","Year","Period","Location","Group"
#       (either missing or same everywhere)
# Check why OAG can't be low: extrap age and OAnew can't conflict

#' @title `extension_check`
#' @description Check the provided files extension.
#' @param user_file character. File name with corresponding extension e.g. Should be one of ".csv",".xlsx",".xls",".tsv"
#' @return A character string with the corresponding file extension.
#' @importFrom stringr str_detect
#' @export
#' @examples
#' \dontrun{
#' extension_check(
#'     user_file = "data.csv")
#' }
#'

extension_check <- function(user_file) {
  # consider txt if it's delimited and reads correctly by read_delim()?
  # but we need to cathc failures intelligently in that case. A standard HMD
  # file would fail, for instance, but maybe it also should fail.
  allow_extensions <- c("csv", "xlsx", "xls", "tsv", "txt")
  ind                  <- str_detect(user_file, pattern = paste0(".", allow_extensions, "$"))
  allow_extensions[ind]
  
  }

#' @title `check_numeric`
#' @description Check if the following columns are numeric: (`Deaths`, `Exposures`, `Age`, and `AgeInt`).
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom purrr map
#' @importFrom rlang .data
#' @importFrom stringr str_flatten
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_numeric(
#'     data = data)

check_numeric <- function(data) {
  # data <- subset(data, select = c("Deaths", "Exposures", "Age", "AgeInt"))
  data <- subset(data, 
                 select = c("Deaths", 
                            "Exposures", 
                            "Age"))
  isnumeric <- data |>
    map( ~ is.numeric(.)) |>
    unlist()
  
  if (sum(isnumeric) < ncol(data)) {
    message <- paste0(
      "Please check the input data. Every column should be numeric, while columns ",
      str_flatten(names(data)[!isnumeric], collapse = ", "),
      " are not."
    )
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check numeric", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_missing_cols`
#' @description Check if any of the crucial columns are missing from the data: (`Deaths`, `Exposures`, `Age`).
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_missing_cols(
#'     data = data)
#'

# Should we even ask some of these? Like if there is no AgeInt the reader will not work.

check_missing_cols <- function(data) {
  # TR: DemoTools has the function age2int() to infer age intervals from an Age vector,
  # to technically we don't need it. We do however need ages specified as lower bounds of
  # abridged age groups (for the abridged lifetable function anyway). Let's not insist on
  # AgeInt being given.
  
  # TODO: Sex should not be insisted upon, but if it's there we should validate values
  # data <- subset(data, select = c("Deaths", "Exposures", "Age", "AgeInt", "Sex"))
  #
  # missing_cols <- setdiff(c("Deaths", "Exposures", "Age", "AgeInt", "Sex"), names(data))
  data <- subset(data, 
                 select = c("Deaths", 
                            "Exposures", 
                            "Age"))
  
  missing_cols <- setdiff(c("Deaths", 
                            "Exposures", 
                            "Age"), names(data))
  
  if (length(missing_cols) > 0) {
    message <- str_c(
      "The following columns are missing from the data:- ",
      str_flatten(missing_cols, collapse = ", "),
      ". The calculations are halted."
    )
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check missing columns", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_rows`
#' @description Check number of rows in the data. NOTE: only using the following columns: (`Deaths`, `Exposures`, `Age`, and `AgeInt`).
#' @param data tibble. A tibble generated by the output of the `read_data` function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)))
#'
#' check_rows(
#'     data = data)

check_rows <- function(data) {
  if (nrow(data) < 10) {
    message <- "The number of rows in the datast is less than expected. Please check the data before proceeding with calculations"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check number of rows", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_nas`
#' @description Check if there missing data
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @importFrom dplyr last
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_nas(
#'     data = data)

check_nas <- function(data) {
  nas <- data |>
    is.na() |>
    colSums()
  if (any(names(nas) == "AgeInt")) {
    if (nas["AgeInt"] == 1 & is.na(last(data$AgeInt))) {
      nas["AgeInt"] <- 0
    }
  }
  
  if (sum(nas) > 0) {
    message <- str_c(
      "Following columns have missing data:- ",
      str_flatten(names(nas)[nas > 0], collapse = ", "),
      ", n = ",
      str_flatten(nas[nas > 0], collapse = ", "),
      ". Please ensure there are no mistakes."
    )
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check = "check missing rows", message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_coherent`
#' @description Check for coherence within Age and between Age and AgeInt
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_coherent
#' @export
#' @examples
#' library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_coherent(
#'     data = data)

check_coherent <- function(data) {
  if ("AgeInt" %in% colnames(data)) {
    tst <- is_age_coherent(data$Age, data$AgeInt)
  } else {
    tst <- TRUE
  }
  if (!tst) {
    message <- "Age classes and age intervals are not coherent"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check = "check age coherency", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_sequential`
#' @description Checks if Age is sorted sequentially
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_sequential
#' @export
#' @examples
#' library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_sequential(
#'     data = data)

check_sequential <- function(data) {
  tst <- is_age_sequential(data$Age)
  
  if (!tst) {
    message <- "The age is not sequential"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age sequential", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_redundant`
#' @description Check for redundant age specification
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_redundant
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_redundant(
#'     data = data)

check_redundant <- function(data) {
  if ("AgeInt" %in% colnames(data)) {
    tst <- is_age_redundant(data$Age, data$AgeInt)
  } else {
    tst <- FALSE
  }
  if (tst) {
    message <- "Provided age data is redundant"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age redundancy", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_lower`
#' @description Check if ages start with 0.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_lower(
#'     data = data)

check_lower <- function(data) {
  if (min(data$Age) != 0) {
    message <- "Age should start with 0."
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check lower age", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_sex`
#' @description Checks the data on sex provided by the user. We expect it ot be provided and contain information on either Males or Females or both. So that the column sex has either one, or two levels.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA),
#'                        sex = "Male")
#'
#' check_sex(
#'     data = data)
#'

check_sex <- function(data) {
  if (any(str_detect("Sex", names(data)))) {
    lvls <- unique(data$Sex)
    
    if (all(lvls %in% c("Male", "Female", "Total"))) {
      message <- NA_character_
      
    } else {
      message <- "If Sex variable is given, it should be coded with either `Male`, `Female`, or `Total`."
      
    }
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check sex", message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
}

#' @title `check_data`
#' @description Upper level function that checks the data quality. Checks if the columns are numeric, if any of the columns is missing, if there is insufficient rows, if there are missing data entries, if ages do not start with 0, and also if ages are coherent, sequential and not redundant.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @importFrom stringr str_c str_detect str_flatten
#' @importFrom DemoTools is_age_redundant is_age_sequential is_age_coherent
#' @importFrom purrr map
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
# data <- tibble(Deaths = Deaths,
#                        Exposures = Exposures,
#                        Age = c(0, 1, seq(5, 100, by = 5)),
#                        AgeInt = c(diff(Age), NA))
# 
# lt_external_plausibility(
#     data = data)

lt_external_plausibility <- function(data) {
  
  # Ensure '.id' column exists
  if (!(".id" %in% colnames(data))) {
    data$.id <- "all"
  }
  
  # Extract unique .id values
  id <- unique(data$.id)
  
  # Perform checks

  
  # Split data by '.id', apply checks, and combine results
  split_data <- split(data, data$.id)
  
  ch1 <- do.call(rbind, lapply(split_data, check_numeric))
  ch2 <- do.call(rbind, lapply(split_data, check_missing_cols))
  ch3 <- do.call(rbind, lapply(split_data, check_rows))
  ch4 <- do.call(rbind, lapply(split_data, check_nas))
  ch5 <- do.call(rbind, lapply(split_data, check_coherent))
  ch6 <- do.call(rbind, lapply(split_data, check_sequential))
  ch7 <- do.call(rbind, lapply(split_data, check_redundant))
  ch8 <- do.call(rbind, lapply(split_data, check_lower))
  ch9 <- do.call(rbind, lapply(split_data, check_sex))
  
  # Combine all the check results

  result <- do.call(rbind, list(ch1, ch2, ch3, 
                                ch4, ch5, ch6, 
                                ch7, ch8, ch9))

  
  return(result)
}

